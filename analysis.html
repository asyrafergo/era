<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Drive PDFs → ChatGPT Table Merge → Download</title>
  <style>
    body { font-family: system-ui, Arial; padding: 18px; max-width: 980px; margin: auto; }
    button { padding:10px 14px; margin-right:8px; cursor:pointer; }
    .thumb { width:140px; margin:6px; border:1px solid #ddd; }
    .images { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    textarea { width:100%; height:160px; margin-top:8px; font-family: monospace; }
    .file-entry { border:1px solid #eee; padding:10px; border-radius:6px; margin-top:10px; }
    .controls { margin-top:14px; }
    .loading { display:inline-block; margin-left:8px; font-style:italic; color:#444; }
    pre { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body>
  <h2>Drive Folder PDF Reader (OAuth) + ChatGPT Table Merge</h2>
  <p>Loads PDFs from Google Drive → extracts text → sends instruction + text to ChatGPT via your backend → returns a merged task table. You can then download the result as PDF or Word.</p>

  <div>
    <button id="authBtn">Sign in & load PDFs</button>
    <button id="signoutBtn" style="display:none">Sign out</button>
  </div>

  <div id="status" style="margin-top:12px;color:#333"></div>

  <h3>Files found</h3>
  <div id="filesList"></div>

  <h3>Combined extracted text</h3>
  <textarea id="combinedText" placeholder="Extracted text will appear here..."></textarea>

  <h3>Thumbnails</h3>
  <div id="images" class="images"></div>

  <!-- Libraries -->
  <script src="https://unpkg.com/pdfjs-dist@3.6.172/build/pdf.min.js"></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
// ==================== CONFIG ====================
const BACKEND_URL = "https://pdf-summarize-3go5.onrender.com/summarize"; // <<— your backend
const OAUTH_CLIENT_ID = '365509237422-i3lq53klim7uk6ub0ndh1vag17078lkm.apps.googleusercontent.com';
const API_KEY = 'AIzaSyCQMc9sbjDLsYsSzrpdGyyXUH4q0uCb5UE';
const TARGET_FOLDER_ID = '1uheM2o-LZsoslFv59ccQox4PUjAL0PjS';
const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';

// System prompt: precise instruction for creating the merged table
const SYSTEM_INSTRUCTION = `You are an expert ergonomics assessor. Using the extracted content from two reports (Report 1 and Report 2), produce ONE combined and harmonized task table in the following exact style:

--------------------------------------------
Table Format Required (Markdown table):

Column 1: "No"
Column 2: "Tasks and Description"
Column 3: "Workers/Activities"
--------------------------------------------

For each task found across the reports, create one table row with:
- No: sequential number starting at 1.
- Tasks and Description: The task title (bold). Under it, list any photo notes as bullet items like:
  • Photo: <caption or short description>
  Then a brief combined description of the task (one or two short sentences).

- Workers/Activities: A bullet list of steps (Step 1, Step 2, ...) extracted and merged from both reports. Use "Step N:" prefix for each bullet. Merge duplicated steps, preserve numeric weights/values (e.g., 25 kg), and harmonize wording. Keep steps ordered logically. Bold critical actions such as **manually transfers**, **lifts**, **pushes**, **uses machine**, etc.

Rules:
- Merge duplicated or overlapping steps into one clear step.
- If both reports provide different details for the same step, harmonize into a single concise step that includes relevant numbers/weights and mentions differences in parentheses if necessary.
- Do not ask the user for more content.
- Output ONLY a valid Markdown table (pipe-separated) with a header row and separator row. No surrounding explanation or commentary.
- Keep language professional and concise.

Goal:
Produce a final merged table that lists all tasks from both reports (as many rows as there are distinct tasks), with merged steps and photo notes where available.
`;

// pdf.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.6.172/build/pdf.worker.min.js';

// UI refs
const authBtn = document.getElementById('authBtn');
const signoutBtn = document.getElementById('signoutBtn');
const statusEl = document.getElementById('status');
const filesList = document.getElementById('filesList');
const combinedTextEl = document.getElementById('combinedText');
const imagesDiv = document.getElementById('images');

let gapiInited = false;
let tokenClient;
let accessToken = null;

// create summarizer UI
const summarizeBtn = document.createElement('button');
summarizeBtn.textContent = 'Summarize & Create Table (ChatGPT)';
summarizeBtn.style.marginTop = '12px';
const loadingSpan = document.createElement('span');
loadingSpan.className = 'loading';
loadingSpan.style.display = 'none';
loadingSpan.textContent = 'Waiting for ChatGPT...';
const downloadPdfBtn = document.createElement('button');
downloadPdfBtn.textContent = 'Download PDF';
downloadPdfBtn.style.display = 'none';
const downloadDocBtn = document.createElement('button');
downloadDocBtn.textContent = 'Download Word (.doc)';
downloadDocBtn.style.display = 'none';
const resultBox = document.createElement('textarea');
resultBox.placeholder = 'ChatGPT returned Markdown table will appear here...';
resultBox.style.height = '220px';
resultBox.style.marginTop = '10px';

// append controls after combined text area
combinedTextEl.parentNode.insertBefore(summarizeBtn, combinedTextEl.nextSibling);
combinedTextEl.parentNode.insertBefore(loadingSpan, summarizeBtn.nextSibling);
combinedTextEl.parentNode.insertBefore(downloadPdfBtn, loadingSpan.nextSibling);
combinedTextEl.parentNode.insertBefore(downloadDocBtn, downloadPdfBtn.nextSibling);
combinedTextEl.parentNode.insertBefore(resultBox, downloadDocBtn.nextSibling);

// ==================== Google API helpers ====================
function gapiLoaded() { gapi.load('client', initializeGapiClient); }

async function initializeGapiClient() {
  try {
    await gapi.client.init({
      apiKey: API_KEY,
      discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"]
    });
    gapiInited = true;
    statusEl.textContent = 'Google API client initialized.';
  } catch (err) {
    statusEl.textContent = 'Error initializing gapi: ' + err.message;
  }
}

function waitForGoogleThenInitTokenClient() {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    (function check() {
      if (window.google && google.accounts && google.accounts.oauth2) {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: SCOPES,
          callback: (resp) => {
            if (resp.error) {
              statusEl.textContent = 'Auth error: ' + resp.error;
              return;
            }
            accessToken = resp.access_token;
            authBtn.style.display = 'none';
            signoutBtn.style.display = 'inline-block';
            statusEl.textContent = 'Signed in.';
            listPdfFilesInFolder();
          }
        });
        resolve();
      } else if (Date.now() - start > 5000) {
        reject(new Error('Google Identity Services did not load'));
      } else setTimeout(check, 100);
    })();
  });
}

async function signOut() {
  if (accessToken) {
    await fetch(`https://oauth2.googleapis.com/revoke?token=${accessToken}`, { method: 'POST' });
  }
  accessToken = null;
  statusEl.textContent = 'Signed out.';
  authBtn.style.display = '';
  signoutBtn.style.display = 'none';
  filesList.innerHTML = '';
  combinedTextEl.value = '';
  imagesDiv.innerHTML = '';
  resultBox.value = '';
  downloadPdfBtn.style.display = 'none';
  downloadDocBtn.style.display = 'none';
}

// ==================== List & parse PDFs ====================
async function listPdfFilesInFolder() {
  if (!gapiInited) return alert('gapi not ready');
  statusEl.textContent = 'Listing PDF files...';
  filesList.innerHTML = '';
  combinedTextEl.value = '';
  imagesDiv.innerHTML = '';
  resultBox.value = '';
  downloadPdfBtn.style.display = 'none';
  downloadDocBtn.style.display = 'none';

  const q = `'${TARGET_FOLDER_ID}' in parents and mimeType='application/pdf' and trashed=false`;
  try {
    const resp = await gapi.client.drive.files.list({ q, fields: 'files(id,name,size)', pageSize: 50 });
    const files = resp.result.files || [];
    if (!files.length) return statusEl.textContent = 'No PDFs found in folder.';
    statusEl.textContent = `Found ${files.length} PDFs — downloading & parsing...`;

    let aggregate = '';
    for (const f of files) {
      const row = document.createElement('div');
      row.className = 'file-entry';
      row.innerHTML = `<b>${f.name}</b> (${f.size || 'unknown'} bytes)`;
      filesList.appendChild(row);

      try {
        const buf = await downloadFileAsArrayBuffer(f.id);
        const parsed = await extractPdfTextAndThumbnails(buf, f.name);
        aggregate += parsed.text + '\n\n';
        parsed.thumbs.forEach(t => {
          const img = document.createElement('img');
          img.src = t.dataUrl;
          img.className = 'thumb';
          imagesDiv.appendChild(img);
        });
        row.appendChild(document.createElement('div')).innerText = 'Parsed OK';
      } catch (e) {
        console.error(e);
        row.appendChild(document.createElement('div')).innerText = 'Error parsing: ' + e.message;
      }
    }
    combinedTextEl.value = aggregate || '';
    statusEl.textContent = 'All PDFs processed.';
  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Error listing files: ' + err.message;
  }
}

async function downloadFileAsArrayBuffer(fileId) {
  if (!accessToken) throw new Error('No access token');
  const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media`;
  const r = await fetch(url, { headers: { Authorization: 'Bearer ' + accessToken }});
  if (!r.ok) throw new Error('Download failed: ' + r.status);
  return await r.arrayBuffer();
}

async function extractPdfTextAndThumbnails(arrayBuffer, name) {
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let text = '';
  const thumbs = [];
  for (let p = 1; p <= pdf.numPages; p++) {
    const page = await pdf.getPage(p);
    const txt = await page.getTextContent();
    const pageText = txt.items.map(i => i.str).join(' ');
    text += `\n--- ${name} PAGE ${p} ---\n` + pageText;
    const viewport = page.getViewport({ scale: 1.2 });
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(viewport.width);
    canvas.height = Math.floor(viewport.height);
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
    thumbs.push({ dataUrl: canvas.toDataURL('image/jpeg', 0.8) });
  }
  return { text, thumbs };
}

// ==================== Summarize with ChatGPT (backend) ====================
summarizeBtn.addEventListener('click', async () => {
  const text = combinedTextEl.value.trim();
  if (!text || text.length < 20) {
    alert('No extracted text available — load PDFs first.');
    return;
  }

  summarizeBtn.disabled = true;
  loadingSpan.style.display = 'inline-block';
  resultBox.value = '';
  downloadPdfBtn.style.display = 'none';
  downloadDocBtn.style.display = 'none';

  try {
    // Send both instruction & extracted text to backend
    const resp = await fetch(BACKEND_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        instruction: SYSTEM_INSTRUCTION,
        text: text
      })
    });

    if (!resp.ok) {
      const txt = await resp.text().catch(()=>null);
      throw new Error(txt || `${resp.status} ${resp.statusText}`);
    }

    const data = await resp.json();
    // backend expected to return { summary: "..." } where summary is the markdown table
    const summary = data.summary || data.result || data.message || '';
    if (!summary) {
      resultBox.value = 'No summary returned from backend.';
    } else {
      resultBox.value = summary;
      // enable downloads
      downloadPdfBtn.style.display = 'inline-block';
      downloadDocBtn.style.display = 'inline-block';
    }
  } catch (err) {
    console.error(err);
    resultBox.value = 'Error: ' + (err.message || err);
  } finally {
    summarizeBtn.disabled = false;
    loadingSpan.style.display = 'none';
  }
});

// ==================== Download helpers ====================
downloadPdfBtn.addEventListener('click', () => {
  const text = resultBox.value || '';
  if (!text) return alert('No summary to download.');
  // create simple PDF using jsPDF
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: 'pt', format: 'a4' });
  const margin = 40;
  const pageWidth = doc.internal.pageSize.getWidth() - margin*2;
  const lines = doc.splitTextToSize(text, pageWidth);
  doc.text(lines, margin, 60);
  doc.save('summary_table.pdf');
});

downloadDocBtn.addEventListener('click', () => {
  const text = resultBox.value || '';
  if (!text) return alert('No summary to download.');
  // create an HTML wrapper — Word can open .doc files that contain HTML
  const title = 'Merged Task Table Summary';
  const html = `
    <html>
      <head><meta charset="utf-8"><title>${title}</title></head>
      <body>
        <h2>${title}</h2>
        <pre style="font-family:inherit;white-space:pre-wrap;">${escapeHtml(text)}</pre>
      </body>
    </html>`;
  const blob = new Blob([html], { type: 'application/msword' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'merged_task_table.doc';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 10000);
});

function escapeHtml(s) {
  return (s || '').replace(/[&<>"']/g, m =>
    ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]) );
}

// ==================== Boot & UI wiring ====================
authBtn.addEventListener('click', async () => {
  if (!gapiInited) {
    await new Promise(r => gapi.load('client', r));
    await initializeGapiClient();
  }
  await waitForGoogleThenInitTokenClient();
  tokenClient.requestAccessToken();
});

signoutBtn.addEventListener('click', signOut);

window.onload = () => {
  if (typeof gapi === 'undefined') {
    statusEl.textContent = 'Google API script not loaded.';
  } else {
    gapiLoaded();
    statusEl.textContent = "Ready. Click 'Sign in & load PDFs'.";
  }
};
</script>
</body>
</html>
